class inherited Ѕазовый.—правочники.интјдрес "»нтарфейс адреса дл€ соц.страх.";

import Ѕазовый classes  онстанты;


inclass public

  func —в€занный ласс«аписей: class —»—2.Ѕазова€.Ѕазова€«апись;
    Result = Ѕазовый.—правочники.јдрес;
  end;

  func Create: —правочники.интјдрес—оц—трах;
    Result = inherited Create;
    Result.Record = Ѕазовый.—правочники.јдрес.Create;
  end;

  func ќткрытьѕо«аписи synonym OpenRecord (locRecord: Ѕазовый.—правочники.јдрес): —правочники.интјдрес—оц—трах;
    Result = inherited Create;
    Result.Record = locRecord;
  end;

  func Ѕланк–едакторѕо”молчанию: class BlankForm;
    Result = —правочники.редјдрес—оц—трах;
  end;

  func  артотекаѕо”молчанию: class CardForm;
    Result = —правочники.картјдрес—оц—трах;
  end;



----------------------------------------------------------------------------
--только дл€ соц.страх.



proc јдрес–егистрацииѕо”мол (лок«а€вка : ƒанные.«а€вкаЌаЌазначениеѕособи€);
  var локјдрес_‘Ћ : Ѕазовый.—правочники.јдрес;
  var лок‘изЋицо : Ѕазовый.ƒанные.—убъект;
  var лок»нт : —правочники.интјдрес—оц—трах;
    лок‘изЋицо = лок«а€вка.—отрудник.‘изЋицо;
    локјдрес_‘Ћ = “ЅЅ_Ѕазовый.Ѕиблио.ѕолучитьјдрес—убъекта(лок‘изЋицо,Today);
    if (локјдрес_‘Ћ <> nil) :
      лок»нт = —оздать опиюƒл€«а€вки»“ипа(локјдрес_‘Ћ,лок«а€вка,тапѕрописка);
      лок»нт.Record.Post;
    else
      лок»нт = —оздатьѕо«а€вке»“ипу(лок«а€вка,тапѕрописка);
      лок»нт.Record.Post;
    fi;
end;


--@doc возвращает интерыейс дл€ новой записи, созданной копированием локјдрес
func —оздать опиюƒл€«а€вки»“ипа(локјдрес : Ѕазовый.—правочники.јдрес;
                                лок«а€вка : ƒанные.«а€вкаЌаЌазначениеѕособи€;
                                лок“ипјдреса : integer) : —правочники.интјдрес—оц—трах;
  var локѕараметры[2] : variant;
    локѕараметры = —оздатьѕараметры«аписиѕо«а€вке(лок«а€вка);
    Result = inherited Create;
    Result.Record = локјдрес.Clone;
    Result.”далить—убъекта;
    Result.«аписатьѕараметры«а€вки(локѕараметры);
    Result.«аписать“ипјдреса(лок“ипјдреса);
end;

func —оздатьѕо«а€вке»“ипу(лок«а€вка : ƒанные.«а€вкаЌаЌазначениеѕособи€; лок“ипјдреса : integer) : —правочники.интјдрес—оц—трах;
  var локѕараметры[2] : variant;
    локѕараметры = —оздатьѕараметры«аписиѕо«а€вке(лок«а€вка);
    Result = inherited Create;
    Result.Record = Ѕазовый.—правочники.јдрес.Create;
    Result.”становитьѕараметрыЌовой«аписи (локѕараметры);
    Result.»нициализироватьѕо”молчанию;
    Result.«апись“ипјдреса(лок“ипјдреса);
end;

func —оздатьѕараметры«аписиѕо«а€вке(лок«а€вка : ƒанные.«а€вкаЌаЌазначениеѕособи€) : variant[2];
  Result = nil;
  Result[1] = ['«а€вкаЌаЌазначениеѕособи€',лок«а€вка];
  Result[2] = ['ѕолучатель‘изЋицо',лок«а€вка.—отрудник.‘изЋицо];
  --Result[3] = ['—убъект',nil];
end;


func ќткрытьѕо«а€вке»“ипу (лок«а€вка : ƒанные.«а€вкаЌаЌазначениеѕособи€;
                           лок“ипјдреса : integer): —правочники.интјдрес—оц—трах;
  var локјдрес : Ѕазовый.—правочники.јдрес;
    Result = nil;
    if (лок«а€вка = nil) :
      return nil;
    fi;
    локјдрес = Ќайтијдресѕо«а€вке»“ипу(лок«а€вка,лок“ипјдреса);
    if (локјдрес = nil) :
      return nil;
    fi;
    Result = ќткрытьѕо«аписи(локјдрес);
end;



func —оздатьјдрес–егистрации(лок«а€вка : ƒанные.«а€вкаЌаЌазначениеѕособи€): —правочники.интјдрес—оц—трах;
  var locValuePosition: variant[];
  var p : integer;
  var локјдрес_‘Ћ : Ѕазовый.—правочники.јдрес;
  var лок‘изЋицо : Ѕазовый.ƒанные.—убъект;
    Result = nil;
    locValuePosition[1] = '—оздать новый';
    locValuePosition[2] = '¬ыбрать из карточки сотрудника)';
    p = PopupMenu(locValuePosition);
    if (p = 1):
      return —оздатьѕо«а€вке»“ипу(лок«а€вка,тапѕрописка);
    elsif (p = 2):
      лок‘изЋицо = лок«а€вка.—отрудник.‘изЋицо;
      локјдрес_‘Ћ = nil;
      Ѕазовый.—правочники.картјдрес.¬ыполнить¬ыбор(лок‘изЋицо,локјдрес_‘Ћ);
      if (локјдрес_‘Ћ <> nil) :
        return —оздать опиюƒл€«а€вки»“ипа(локјдрес_‘Ћ,лок«а€вка,тапѕрописка);
      fi;
    end;

end;

func —оздатьјдресѕроживани€(локјдрес–ег : Ѕазовый.—правочники.јдрес;
                            лок«а€вка : ƒанные.«а€вкаЌаЌазначениеѕособи€): —правочники.интјдрес—оц—трах;
  var locValuePosition: variant[];
  var p : integer;
  var локјдрес_‘Ћ : Ѕазовый.—правочники.јдрес;
  var лок‘изЋицо : Ѕазовый.ƒанные.—убъект;
    Result = nil;
    locValuePosition[1] = '—оздать новый';
    locValuePosition[2] = '¬ыбрать из карточки сотрудника)';
    if (локјдрес–ег <> nil) :
      locValuePosition[3] = '—копировать адрес регистрации)';
    fi;
    p = PopupMenu(locValuePosition);
    if (p = 1):
      return —оздатьѕо«а€вке»“ипу(лок«а€вка,тап‘актический);
    elsif (p = 2):
      лок‘изЋицо = лок«а€вка.—отрудник.‘изЋицо;
      локјдрес_‘Ћ = nil;
      Ѕазовый.—правочники.картјдрес.¬ыполнить¬ыбор(лок‘изЋицо,локјдрес_‘Ћ);
      if (локјдрес_‘Ћ <> nil) :
        return —оздать опиюƒл€«а€вки»“ипа(локјдрес_‘Ћ,лок«а€вка,тап‘актический);
      fi;
    elsif (p = 3):
      return —оздать опиюƒл€«а€вки»“ипа(локјдрес–ег,лок«а€вка,тап‘актический);
    end;

end;



func јдрес–егистрацииѕо«а€вке(лок«а€вка : ƒанные.«а€вкаЌаЌазначениеѕособи€) : Ѕазовый.—правочники.јдрес;
  Result = nil;
  if (лок«а€вка <> nil) :
    return Ќайтијдресѕо«а€вке»“ипу(лок«а€вка,тапѕрописка);
  fi;
end;
func јдресѕроживани€ѕо«а€вке(лок«а€вка : ƒанные.«а€вкаЌаЌазначениеѕособи€) : Ѕазовый.—правочники.јдрес;
  Result = nil;
  if (лок«а€вка <> nil) :
    return Ќайтијдресѕо«а€вке»“ипу(лок«а€вка,тап‘актический);
  fi;
end;

func Ќайтијдресѕо«а€вке»“ипу(лок«а€вка : ƒанные.«а€вкаЌаЌазначениеѕособи€; лок“ипјдреса : integer) : Ѕазовый.—правочники.јдрес;
  var лок«апись“ипајдреса : Ѕазовый.—правочники.“ипјдреса;
  лок«апись“ипајдреса = «апись“ипјдреса (лок“ипјдреса);
  Result = nil;
  with Query.Create([Ѕазовый.—правочники.јдрес]) do
    Filter = '«а€вкаЌаЌазначениеѕособи€ = ' + Str(лок«а€вка);
    Select;
    while not EOF do
      if (Current.ѕозиции[1].“ипјдреса = лок«апись“ипајдреса) :
        Result = Current;
        break;
      fi;
      Next;
    end;
  end;
end;

func јдрес—трокойѕо«аписи(локјдрес : Ѕазовый.—правочники.јдрес) : string;
  Result = '';
  if (локјдрес <> nil) :
    Result = локјдрес.јдрес_—трокой;
    if (Result = '') :
      Result = јдрес_ќбщий(локјдрес);
    fi;
    Result = ѕогаситьЋишние«ап€тые(Result);
  fi;
end;






inobject public

  Record: Ѕазовый.—правочники.јдрес;

  --@doc ѕри создании новой записи
proc »нициализироватьѕо”молчанию synonym InitByDefault;
  inherited InitByDefault;
end;

--proc Init;
  
--end;

proc «аписатьѕараметры«а€вки(локѕараметры[2] : variant);
  var i,nn : integer;
    nn = LengthOfArray(локѕараметры);
    for i = 1..nn do
      Self.Record.SetField(локѕараметры[i,1],локѕараметры[i,2]);
    end;
end;

proc ”далить—убъекта;
 Self.Record.—убъект = nil;
end;


proc «аписать“ипјдреса (лок“ипјдреса : integer);
  var лок«апись“ипјдреса  : Ѕазовый.—правочники.“ипјдреса;
  var i : integer;
    лок«апись“ипјдреса = «апись“ипјдреса (лок“ипјдреса);
    Self.Record.ѕозиции.Clear;
    i =  Self.Record.ѕозиции.Add;
    Self.Record.ѕозиции[i].“ипјдреса = лок«апись“ипјдреса;
    --Self.Record.Post;
end;

func јдрес—трокой : string;
  Result = Self.Record.јдрес_—трокой;
  if (Result = '') :
    Result = јдрес_ќбщий(Self.Record);
  fi;
  Result = ѕогаситьЋишние«ап€тые(Result);
end;


inclass private

func «апись“ипјдреса (лок“ипјдреса : integer): Ѕазовый.—правочники.“ипјдреса;
  var aTxt: string[];
  var лок‘ильтр : string;
    aTxt[1] = " од='" + ѕредопределени€[лок“ипјдреса,1] +"'";
    aTxt[2] = "ƒл€‘излиц";
    лок‘ильтр = —»—2.—троковые‘ункции.—ложить—троки‘ильтраѕо»(aTxt);
    Result = —»—2.‘ункцииƒокумента.QueryRecord(Ѕазовый.—правочники.“ипјдреса, лок‘ильтр);
end;


func ѕогаситьЋишние«ап€тые(локјдрес—трокой : string) : string;
  var i : integer;
    Result = локјдрес—трокой;
    while Result <> '' do
      if (Substr(Result,1,1) = ',') :
        Result = if(Length(Result) > 1 : Substr(Result,2,Length(Result) - 1), '');
      else
        break;
      fi;
    end;
    while Result <> '' do
      if (Substr(Result,Length(Result),1) = ',') :
        Result = Substr(Result,2,Length(Result) - 1);
      else
        break;
      fi;
    end;
    i = pos(',,',Result);
    while i <> 0  do
      Result = Substr(Result,1,i) + Substr(Result,i+2,Length(Result) - i - i);
      i = pos(',,',Result);
    end;
end;




end